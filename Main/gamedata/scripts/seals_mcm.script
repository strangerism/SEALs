disable_pistols = false

local options = {
    debug = true
}

local mcm_id = "seals"

local string_format = string.format
local string_find   = string.find
properties = {}
layers = {}
groups = {}


local op = { id = mcm_id, gr = {} }
main_settings_path = string_format("%s/%s_main_settings", mcm_id, mcm_id) .. "/%s"

op.gr[1] = { id = mcm_id .. "_main_settings", sh = true, gr = {
    { id = "title", type= "slide", link= "ui_seals_mcm_banner", text= "", --[[size= {512,50},]]spacing = 20 },
}}

function print_table(text, node, ...)
    if (options.debug) then
        text = string_format(text, ...)
        printf("Seal Overlayer: | %s | \n" .. utils_data.print_table(node, text, true), time_global(), ...)
    end
end

function print_dbg(text , ...)
	if (options.debug) then
		printf("Seal Overlayer: | %s | " .. text, time_global(), ...)
	end
end

anchors = {
    x = {
        right = function(axis, margin, w)
            return (axis.w - w) - margin
        end,
        left = function(axis, margin, w)
            return margin
        end,
        center = function(axis, margin, w)
            return ((axis.w * 0.5) - (w  * 0.5)) + margin
        end,
    },
    y = {
        top = function(axis, margin, h)
            return margin
        end,
        bottom = function(axis, margin, h)
            return (axis.h - h) - margin
        end,
        center = function(axis, margin, h)
            return ((axis.h * 0.5) - (h  * 0.5)) - margin
        end,
    }
}

function get_config(path, config, def)
    if not ui_mcm then
        return def
    end

    return ui_mcm.get(string_format(path, config))
end

function parse_properties()
    print_dbg("- SEALs parse_properties ")
    local property_kinds_ini = ini_file_ex("custom_seal_layers\\properties\\kinds\\base_seals_kinds.ltx")
    local kinds = property_kinds_ini:get_sections()

    for i = 1, #kinds do
        repeat
            local kind = kinds[i]
            if string_find(kind, "_base") then
                do break end
            end
            properties[kind] = {}
            local functor = property_kinds_ini:r_string_ex(kind, "functor")
            if functor then
                -- print_dbg("kind = %s", kind)
                -- print_dbg("test read prop show %s", property_kinds_ini:r_bool_ex(kind, "show"))
                -- print_dbg("test read prop scale %s", property_kinds_ini:r_float_ex(kind, "scale"))
                properties[kind].functor = str_explode(functor, ",")
                properties[kind].props = {}
                properties[kind].default_settings = {
                    ["show"] = property_kinds_ini:r_bool_ex(kind, "show") or false,
                    ["rotate"] = property_kinds_ini:r_bool_ex(kind, "rotate") or false,
                    ["scale"] = property_kinds_ini:r_float_ex(kind, "scale") or 1,
                    ["scale_sm"] = property_kinds_ini:r_float_ex(kind, "scale_sm") or 1,
                    ["anchor_x"] = property_kinds_ini:r_string_ex(kind, "anchor_x") or "right",
                    ["anchor_y"] = property_kinds_ini:r_string_ex(kind, "anchor_y") or "bottom",
                    ["offset_x"] = property_kinds_ini:r_float_ex(kind, "offset_x") or 0,
                    ["offset_sm_x"] = property_kinds_ini:r_float_ex(kind, "offset_sm_x") or 0,
                    ["offset_y"] = property_kinds_ini:r_float_ex(kind, "offset_y") or 0,
                    ["offset_sm_y"] = property_kinds_ini:r_float_ex(kind, "offset_sm_y") or 0,
                    ["spacing_x"] = property_kinds_ini:r_float_ex(kind, "spacing_x") or 0,
                    ["spacing_y"] = property_kinds_ini:r_float_ex(kind, "spacing_y") or 0,
                    ["limit"] = property_kinds_ini:r_bool_ex(kind, "limit") or false,
                    ["amount"] = property_kinds_ini:r_float_ex(kind, "amount") or 1
                }
                -- print_dbg("test read show %s", properties[kind].default_settings.show)
                -- print_dbg("test read scale %s", properties[kind].default_settings.scale)
            else
                print_dbg("! No functor defined for the kind [%s]", kind)
            end
        until true
    end

    -- build options
    op.gr[2] = { id = mcm_id .. "_properties", sh = true, gr = {
        { id = "title", type= "slide", link= "ui_seals_mcm_banner", text= "", --[[size= {512,50},]]spacing = 20 }
    }}
    
    for i = 1, #kinds do
        local kind = kinds[i]
        local defaults = properties[kind].default_settings
        -- print_dbg("bulding options for %s", kind)
        -- print_table("default_settings",  properties[kind].default_settings)
        table.insert(op.gr[2].gr, { id = "desc" .. kind, type = "desc", text = string_format("ui_mcm_desc_%s_prop_%s", mcm_id, kind)})
        table.insert(op.gr[2].gr, { id = "show_" .. kind, hint = string_format("%s_show", mcm_id), val = 1, type = "check", def = true })
        -- if kind == "w_pistol" or kind == "w_shotgun" or kind == "w_smg" then
        --     table.insert(op.gr[2].gr, { id = "rotate_" .. kind, hint = string_format("%s_rotate", mcm_id), val = 1, type = "check", def = true })
        --     table.insert(op.gr[2].gr, { id = "scale_sm_" .. kind, hint = string_format("%s_scale_sm", mcm_id), type = "track", val = 2, step = 0.1,def = defaults.scale_sm, max = 5, min = 0.1})
        -- end
        table.insert(op.gr[2].gr, { id = "scale_" .. kind, hint = string_format("%s_scale", mcm_id), type = "track", val = 2, step = 0.1,def = defaults.scale, max = 5, min = 0.1})
        table.insert(op.gr[2].gr, { id = "anchor_x_" .. kind, hint = string_format("%s_anchor_x", mcm_id),  type = "list", val = 0, def = defaults.anchor_x,
            content = { 
                {"right", string_format("%s_right", mcm_id)},
                {"left", string_format("%s_left", mcm_id)},
            }
        })
        table.insert(op.gr[2].gr, { id = "anchor_y_" .. kind, hint = string_format("%s_anchor_y", mcm_id), type = "list", val = 0, def = defaults.anchor_y, 
            content = { 
                {"top", string_format("%s_top", mcm_id)},
                {"bottom", string_format("%s_bottom", mcm_id)},
            }
        })
        table.insert(op.gr[2].gr, { id = "offset_x_" .. kind, hint = string_format("%s_offset_x", mcm_id), type = "track", val = 2, step = 1,def = defaults.offset_x, max = 100, min = -100})
        table.insert(op.gr[2].gr, { id = "offset_y_" .. kind, hint = string_format("%s_offset_y", mcm_id), type = "track", val = 2, step = 1, def = defaults.offset_y, max = 100, min = -100})
        table.insert(op.gr[2].gr, { id = "spacing_x_" .. kind, hint = string_format("%s_spacing_x", mcm_id), type = "track", val = 2, step = 1, def = defaults.spacing_x, max = 10, min = 0})
        table.insert(op.gr[2].gr, { id = "spacing_y_" .. kind, hint = string_format("%s_spacing_y", mcm_id), type = "track", val = 2, step = 1,def = defaults.spacing_y, max = 10, min = 0})
        table.insert(op.gr[2].gr, { id = "limit_" .. kind, hint = string_format("%s_limit", mcm_id), val = 1, type = "check", def = defaults.limit })
        table.insert(op.gr[2].gr, { id = "amount_" .. kind, hint = string_format("%s_amount", mcm_id), type = "track", val = 2, step = 1, def = defaults.amount, max = 10, min = 0 })
        if kind == "w_pistol" or kind == "w_shotgun" or kind == "w_smg" then
            table.insert(op.gr[2].gr, { id = "small_icons" .. kind, type = "desc", clr = {200, 200, 255, 200}, text = "ui_mcm_small_icons_desc"})
            if kind == "w_pistol" or kind == "w_smg" then
                table.insert(op.gr[2].gr, { id = "rotate_" .. kind, hint = string_format("%s_rotate", mcm_id), val = 1, type = "check", def = true })
            end
            table.insert(op.gr[2].gr, { id = "scale_sm_" .. kind, hint = string_format("%s_scale_sm", mcm_id), type = "track", val = 2, step = 0.1,def = defaults.scale_sm, max = 5, min = 0.1})
            table.insert(op.gr[2].gr, { id = "offset_sm_x_" .. kind, hint = string_format("%s_offset_sm_x", mcm_id), type = "track", val = 2, step = 1,def = defaults.offset_sm_x, max = 100, min = -100})
            table.insert(op.gr[2].gr, { id = "offset_sm_y_" .. kind, hint = string_format("%s_offset_sm_y", mcm_id), type = "track", val = 2, step = 1, def = defaults.offset_sm_y, max = 100, min = -100})
        end        
        table.insert(op.gr[2].gr, { id = "divider", type = "line" })
    end
    op.gr[2].gr[#op.gr[2].gr] = nil
end

parse_properties()

property_path = string_format("%s/%s", mcm_id, op.gr[2].id) .. "/%s_"

function get_settings_for_prop(kind)
    local path = property_path .. kind
    local settings = properties[kind].default_settings
    if not ui_mcm then return settings end
    
    for k, v in pairs(settings) do
        settings[k] = get_config(path, k)
    end

    -- print_table("Got settings for kind %s", settings, kind)

    -- for some weird reason these options can get saved as false
    if (not anchors.x[settings.anchor_x]) or (not anchors.y[settings.anchor_y]) then
        settings.anchor_x = "right"
        settings.anchor_y = "bottom"
        print_dbg("Options got corrupted, falling back to defaults")
    end

    return settings
end

local rect_cache = {}

function get_texture_rect(texture, cell, xml)
    if rect_cache[texture] then
        return rect_cache[texture]
    end
    local rect_layer = xml:InitStatic(cell.path .. ":" .. cell.cx .. ":pic", cell.ico)
    rect_layer:InitTexture(texture)
    rect_cache[texture] = rect_layer:GetTextureRect()
    return rect_cache[texture]
end

function parse_groups()
    print_dbg("!! parse_groups")

    local groups_ini = ini_file_ex("custom_seal_layers\\groups\\base_seals_groups.ltx")
    local layers_ini = ini_file_ex("custom_seal_layers\\layers\\base_seals_layers.ltx")
    local group_secs = groups_ini:get_sections()

    for i = 1, #group_secs do
        repeat
            local group = group_secs[i]
            if string_find(group, "_base") then
                do break end
            end

            local items = utils_data.collect_section(groups_ini.ini, group)
            for i = 1 , #items do
                local item = items[i]
                if not groups[item] then
                    groups[item] = {}
                end
                groups[item][#groups[item] + 1] = group
            end
        until true
    end

    local layer_secs = layers_ini:get_sections()

    if is_empty(layer_secs) then return end

    op.gr[3] = { id = mcm_id .. "_custom_layers", gr = {} }
    local tabs = {}

    for i = 1, #layer_secs do
        repeat
            local layer = layer_secs[i]
            if string_find(layer, "_base") then
                do break end -- continue
            end

            local group = layers_ini:r_string_ex(layer, "group")
            if not group then
                print_dbg("! No group specified for the layer: [%s]", layer)
                do break end -- continue
            end

            local settings_group = layers_ini:r_string_ex(layer, "settings_group") or group
            -- create single item groups automatically
            if not groups_ini:section_exist(group) then
                local item = group
                if not groups[item] then
                    groups[item] = {}
                end
                group = string_format("%s_%s", group, layer)
                print_dbg("- Created group %s", group)
                groups[item][#groups[item] + 1] = group
            end

            if not layers[group] then
                layers[group] = {}
            end

            local anchor_str = layers_ini:r_string_ex(layer, "anchor")
            anchor_str = anchor_str and str_explode(anchor_str, "_") or {}
            local anchor = {
                x = anchors.x[anchor_str[1]] and anchor_str[1] or "center",
                y = anchor_str[2] or (anchors.y[anchor_str[1]] and anchor_str[1]) or "center",
            }

            local str = str_explode(settings_group, "/")
            local tab = str[2] and mcm_id .. "_custom_layers_" .. str[1] or mcm_id .. "_custom_layers_main"

            if not tabs[tab] then
                table.insert(op.gr[3].gr, { id =  tab, sh = true, gr = {
                    { id = "title", type= "slide", link= "ui_seals_mcm_banner", text= "", --[[size= {512,50},]]spacing = 20 }
                }})
                tabs[tab] = {idx = #op.gr[3].gr, settings = {}}
            end

            local setting = str[2] or str[1]

            layers[group][layer] = {
                ["primary"]   = layers_ini:r_bool_ex(layer,"primary",false),
                ["overrides"]   = layers_ini:r_string_ex(layer, "overrides") or "",
                ["texture"]  = layers_ini:r_string_ex(layer, "texture") or "ui_buffdebuff_icon_scope",
                ["icon_scale"]   = layers_ini:r_float_ex(layer, "icon_scale") or 1,
                ["tooltip_scale"]   = layers_ini:r_float_ex(layer, "tooltip_scale") or 1,
                ["caption"]   = layers_ini:r_string_ex(layer, "caption") or "Seal",
                ["anchor"]   = anchor,
                ["align"]   = layers_ini:r_string_ex(layer, "align") or 1,
                ["width"]   = layers_ini:r_float_ex(layer, "width") or 25,
                ["margin_horz"] = layers_ini:r_float_ex(layer, "margin_horz") or 1,
                ["margin_vert"] = layers_ini:r_float_ex(layer, "margin_vert") or 1,
                ["settings_path"] = string_format("%s/%s/%s", mcm_id, op.gr[3].id, tab) .. "/%s_" .. setting
            }

            print_table("- Created layer: %s", layers[group][layer], layer)

            if tabs[tab].settings[setting] then
                do break end
            end

            tabs[tab].settings[setting] = true

            table.insert(op.gr[3].gr[tabs[tab].idx].gr, { id = "show_" .. setting, hint = string_format("%s_%s_show", mcm_id, setting), val = 1, type = "check", def = true })
        until true
    end

    -- print_dbg("!! total # of layers %s", #layers)
    -- print_dbg("!! total # of groups %s", #groups)
end

parse_groups()

function on_mcm_load()
    return op
end

layer_functors = {}

layer_functors.custom_layers = function(sec, cell, xml)
    local layer_info = groups[sec]
    if not layer_info then return {} end
    local axis = utils_xml.get_item_axis(sec)

    -- demonized: HD Inventory Icons Framework
    local icon_override = aaa_rax_icon_override_mcm and aaa_rax_icon_override_mcm.icon_override
    local scale = icon_override and icon_override:section_exist(sec) and (icon_override:r_float_ex(sec, "inv_grid_scale") or 1) or SYS_GetParam(2, sec, "inv_grid_scale", 1)
    axis.w = math.ceil(axis.w / scale)
    axis.h = math.ceil(axis.h / scale)
    
    local kind = SYS_GetParam(0,sec,"kind", "na")
    local settings = get_settings_for_prop(kind)
    local custom_layers = {}
    print_dbg("!! MAXXXX custom layer %s", sec)
    print_dbg("is_small_icon %s", is_small_icon(sec))

    local row_width = 0
    local row_index = 0
    local icon_index = 0
    -- Build custom_layers
    for i = 1, #layer_info do
        print_dbg("layer %s", i)
        local group = layers[layer_info[i]]
        for layer, data in pairs(group) do
            repeat
                if not get_config(data.settings_path, "show", true) then
                    print_dbg("!! layer skipped %s", data.caption)
                    do break end -- continue
                end
                print_dbg("layer %s", layer)
                local scale = settings.scale
                if is_small_icon(sec) then
                    scale = settings.scale_sm
                end
                local rect = get_texture_rect(data.texture, cell, xml)
                icon_index = icon_index + 1
                local h = ((rect.y2 - rect.y1) / (data.icon_scale or 1)) * scale
                local w = ((rect.x2 - rect.x1) / (data.icon_scale or 1)) * scale
                local x_offset = icon_index > 1 and (settings.spacing_x) or 0
                row_width = row_width + (w + x_offset)
                if row_width > axis.w and i > 1 then
                    row_index = row_index + 1
                    row_width = w
                    icon_index = 1
                end
                local y_offset = row_index * (settings.spacing_y)
                local x = anchors.x[settings.anchor_x](axis, (row_width - w), w)
                local y = anchors.y[settings.anchor_y](axis, y_offset + (h * row_index), h)
                local offset_x = settings.offset_x
                local offset_y = settings.offset_y
                if is_small_icon(sec) then
                    offset_x = settings.offset_sm_x
                    offset_y = settings.offset_sm_y
                end                
                local layer_tbl = {
                    ["x"] = x - offset_x,
                    ["y"] = y - offset_y,
                    ["h"] = h,
                    ["w"] = w,
                    ["texture"] = data.texture,
                    ["primary"] = data.primary or "",
                    ["overrides"] = data.overrides or "",
                    ["caption"] = data.caption,
                    ["layer"] = layer,
                }

                custom_layers[#custom_layers + 1] = layer_tbl
            until true
        end
    end

    -- Remove overridden layers
    local to_remove = {}
    for i = 1, #custom_layers do
        local overrides = custom_layers[i].overrides
        if overrides and overrides ~= "" then
            -- Find the layer that matches the overrides value and mark it for removal
            for j = 1, #custom_layers do
                if custom_layers[j].layer == overrides then
                    to_remove[j] = true
                end
            end
        end
    end
    local filtered_layers = {}
    for i = 1, #custom_layers do
        if not to_remove[i] then
            filtered_layers[#filtered_layers + 1] = custom_layers[i]
        end
    end
    custom_layers = filtered_layers

    -- Sort custom_layers so that primary=true layers come first, if any exist
    table.sort(custom_layers, function(a, b)
        -- Convert to boolean for strict comparison
        local a_primary = (a.primary == true or a.primary == 1)
        local b_primary = (b.primary == true or b.primary == 1)
        if a_primary == b_primary then
            return false
        end
        return a_primary and not b_primary
    end)

    -- Recalculate x for layers after removal
    row_width = 0
    row_index = 0
    icon_index = 0
    for i = 1, #custom_layers do
        local layer_tbl = custom_layers[i]
        icon_index = icon_index + 1
        local x_offset = icon_index > 1 and (settings.spacing_x) or 0
        row_width = row_width + (layer_tbl.w + x_offset)
        if row_width > axis.w and i > 1 then
            row_index = row_index + 1
            row_width = layer_tbl.w
            icon_index = 1
        end
        local y_offset = row_index * (settings.spacing_y)
        local x = anchors.x[settings.anchor_x](axis, (row_width - layer_tbl.w), layer_tbl.w)
        local y = anchors.y[settings.anchor_y](axis, y_offset + (layer_tbl.h * row_index), layer_tbl.h)
        local offset_x = settings.offset_x
        local offset_y = settings.offset_y
        if is_small_icon(sec) then
            offset_x = settings.offset_sm_x
            offset_y = settings.offset_sm_y
        end
        layer_tbl.x = x - offset_x
        layer_tbl.y = y - offset_y
    end

    print_table("custom_layers", custom_layers)
    return custom_layers
end

function add_texture_layer(self, ele, base, tbl, sec, ele_no)

    local kind = (sec and SYS_GetParam(0,sec,"kind")) or ""
    local settings = get_settings_for_prop(kind)
    if ele_no and settings.limit and ele_no > settings.amount then return end
    
    -- if not sec or not ele_no then return end
    local ratio = utils_xml.screen_ratio()
    local grid_size = self.grid_size
    -- printf("grid_size %s", grid_size)
    local x = tbl.x or 0
    local y = tbl.y or 0
    local w = tbl.w
    local h = tbl.h
    local scale = (grid_size / 50)
    local scale_pos = scale

    local rot =  ele:GetHeading() > 0
    local x_s = x * ratio * scale_pos
    local y_s = y * scale_pos
    local w_s = w * ratio * scale
    local h_s = h * scale
    local w_off = (w_s/2)
    local h_off = (h_s/2)

    local force_rot = false
    local force_factor = 1
    local g_offset = 0
    if is_small_icon(sec) and settings.rotate then
        force_rot = true
        local inv_grid_width = (sec and SYS_GetParam(2,sec,"inv_grid_width",1)) or 1
        force_factor = inv_grid_width - 1
        g_offset = base:GetHeight()/4
    end
    
    if rot or force_rot then
        -- scale = scale / force_factor
        -- despite rotation, movement for x and y stays normal! 
        -- Move start pos to match the one for rotated base icon
        local w_b, h_b = base:GetWidth(), base:GetHeight()
        local x_st = ((w_b/2) - (h_b/2)) 
        local y_st = h_b + x_st
        
        -- On 90 rotation, x and y are inverted, y axis goes negative simulate normal x movement
        x_s = x_st + (y * ratio * scale_pos) - g_offset
        y_s = y_st - (x * scale_pos) - g_offset*2
        w_s = w * scale
        h_s = h * scale
        w_off = (h_s - h_s * ratio/2)
        h_off = -w_s/2
    end
    
    ele:InitTexture( tbl.texture )
    ele:SetStretchTexture(true)

    ele:SetWndPos(vector2():set( (x_s + w_off) , (y_s + h_off) ))
    ele:SetWndSize(vector2():set( w_s , h_s ))
    ele:Show(true)
end

function is_valid_kind(sec)
    local kind = (sec and SYS_GetParam(0,sec,"kind")) or ""

    if kind == "w_pistol" or kind == "w_shotgun" or kind == "w_sniper" or kind == "w_rifle" or kind == "w_smg" then
        return true
    else
        return false
    end

end

function get_all_layers(sec, cell, xml)
    if not is_valid_kind(sec) then return end
    -- print_dbg("!! get_all_layers for %s", sec)
    local seals_layers = {}

    for name, functor in pairs(layer_functors) do
        local layers = functor(sec, cell, xml)
        if not is_empty(layers) then
            for i = 1, #layers do
                seals_layers[#seals_layers + 1] = layers[i]
            end
        end
    end
    -- print_dbg("- Number of layers %s", seals_layers and #seals_layers or 0)
    return seals_layers
end

_Add_Layers = utils_ui.UICellItem.Add_Layers

utils_ui.UICellItem.Add_Layers = function(self, xml, obj, sec, clsid)
    if self.seals_layer then
        for i = 1, #self.seals_layer do
            self.seals_layer[i]:Show(false)
        end
    end

    xml = xml or self:GetXML()
    local seals_layers = get_all_layers(sec, self, xml)

    if not is_empty(seals_layers) then
        if not self.seals_layer then
            self.seals_layer = {}
        end

        for i = 1, #seals_layers do
            if (not self.seals_layer[i]) then

                self.seals_layer[i] = xml:InitStatic(self.path .. ":" .. self.cx .. ":pic", self.ico)
            end
            -- printf(" Add_Layers[%s] = %s", i, seals_layers[i].texture)
            add_texture_layer(self, self.seals_layer[i], self.ico, seals_layers[i], sec, i)
        end
    end

    _Add_Layers(self, xml, obj, sec, clsid)
end

function get_seals(sec)
    local layer_info = groups[sec]
    if not layer_info then return {} end
    local seals = {}
    -- local scale = get_config(main_settings_path, "scale", 1.1)
    -- print_dbg("- MAXXXX get_seals %s", sec)
    for i = 1, #layer_info do
        -- print_dbg("layer %s", i)
        local group = layers[layer_info[i]]
        for layer, data in pairs(group) do
            repeat
                if not get_config(data.settings_path, "show", true) then
                    do break end -- continue
                end
                -- local kind = SYS_GetParam(0,sec,"kind")
                -- if kind == "w_pistol" and disable_pistols then
                --     return
                -- end
                -- print_dbg("- FOUND")
                -- print_dbg("data.texture %s", data.texture)
                -- print_dbg("data.caption %s", data.caption)
                local seal = {
                    ["name"] = layer,
                    ["caption"] = data.caption,
                    ["texture"] = data.texture,
                    ["scale"] = data.tooltip_scale,
                }

                seals[#seals + 1] = seal
            until true
        end
    end

    return seals
end

function is_small_icon(sec)
    local kind = SYS_GetParam(0,sec,"kind", "na")
    local inv_grid_height = (sec and SYS_GetParam(2,sec,"inv_grid_height",1)) or 1
    -- print_dbg("- sec %s inv_grid_height %s", sec, inv_grid_height)
    local is_small_icon = inv_grid_height == 1 and (kind == "w_pistol" or kind == "w_shotgun" or kind == "w_smg") 
    -- print_dbg("is_small_icon %s", is_small_icon)
    return is_small_icon
end

function is_pistol(sec)
    return sec and SYS_GetParam(0,sec,"kind", "na") == "w_pistol"
end

function w_shotgun(sec)
    return sec and SYS_GetParam(0,sec,"kind", "na") == "w_shotgun"
end

function w_sniper(sec)
    return sec and SYS_GetParam(0,sec,"kind", "na") == "w_sniper"
end

function w_rifle(sec)
    return sec and SYS_GetParam(0,sec,"kind", "na") == "w_rifle"
end

function w_smg(sec)
    return sec and SYS_GetParam(0,sec,"kind", "na") == "w_smg"
end